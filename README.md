# CourseworkTask2
# Отчет по проекту: Собственная реализация Reactive Streams (аналог RxJava)

## 1. Введение

В данном отчете описана реализация библиотеки реактивного программирования, построенной на основе ключевых концепций RxJava. Основная цель проекта — создать гибкий механизм обработки асинхронных потоков данных с возможностью управления потоками выполнения, трансформации данных и надёжной обработки ошибок.

## 2. Архитектура системы

### 2.1. Основные компоненты

- **`Observable<T>`** — источник данных, поддерживающий подписку и эмиссию событий.  
- **`Observer<T>`** — интерфейс наблюдателя с методами `onNext`, `onError`, `onComplete`.  
- **`Disposable`** — механизм отмены подписки и освобождения ресурсов.  
- **`OnSubscribe<T>`** — функциональный интерфейс для определения поведения `Observable.create()`.

### 2.2. Поток исполнения и цепочка операторов

Каждый оператор (`map`, `filter`, `flatMap`) возвращает новый `Observable`, оборачивая предыдущий и регистрируя свой `OnSubscribe`. При подписке формируется стек вызовов, где каждый оператор получает событие, обрабатывает его и передаёт дальше.

## 3. Операторы преобразования данных

### 3.1. `map(Function<T,R>)`

Преобразует входные элементы, применяя переданную функцию-Mapper. При возникновении исключения в функции поток закрывается через `onError`.

### 3.2. `filter(Predicate<T>)`

Фильтрует элементы, пропуская только те, которые удовлетворяют предикату. Исключения предиката аналогично приводят к завершению через `onError`.

### 3.3. `flatMap(Function<T, Observable<R>>)` 

Разворачивает каждый входной элемент в под-`Observable`, затем объединяет их эмиссии в один поток. Подписки на внутренние `Observable` учитываются счётчиком активных источников, поток завершается, когда все подписки завершены.

## 4. Управление потоками выполнения (Schedulers)

### 4.1. Интерфейс `Scheduler`

Определяет метод `execute(Runnable)`, принимающий задачу для асинхронного выполнения.

### 4.2. Реализации

- **`IOThreadScheduler`** — `Executors.newCachedThreadPool()` для I/O-операций.  
- **`ComputationScheduler`** — `Executors.newFixedThreadPool(Runtime.getRuntime().availableProcessors())` для CPU-bound задач.  
- **`SingleThreadScheduler`** — `Executors.newSingleThreadExecutor()` для последовательного выполнения.

### 4.3. `subscribeOn` и `observeOn`

- `subscribeOn(scheduler)` — переключает создание и эмиссию на указанный `Scheduler`.  
- `observeOn(scheduler)` — переключает обработку `onNext`/`onError`/`onComplete` на указанный `Scheduler`.  

## 5. Обработка ошибок и отмена подписки

- Все исключения в источнике или операторах передаются в метод `onError` наблюдателя.  
- `Disposable` позволяет прекратить получение событий и корректно освободить внутренние ресурсы.

## 6. Процесс тестирования

- Юнит-тесты для каждого оператора (`map`, `filter`, `flatMap`): проверка корректности работы и обработки ошибок.  
- Тесты для `Schedulers`: проверка переключения контекста на разных реализациях (`IOThreadScheduler`, `ComputationScheduler`, `SingleThreadScheduler`).  
- Тесты для `Disposable`: гарантируют остановку потока по запросу.

## 7. Примеры использования

```java
Observable.create(emitter -> {
    emitter.onNext(1);
    emitter.onNext(2);
    emitter.onComplete();
})
.filter(i -> i % 2 == 0)
.map(i -> "Number: " + i)
.subscribe(
    System.out::println,
    Throwable::printStackTrace,
    () -> System.out.println("Done")
);
```
## 8. Заключение 

Разработанная библиотека демонстрирует основные возможности реактивного программирования: создание потоков, трансформацию данных, асинхронность и надёжную обработку ошибок. Благодаря модульной архитектуре и простому расширению она может служить основой для более сложных систем.
